# R/setup/maintain_env.R
# This script reads DESCRIPTION, extracts dependencies, and generates packages.R and default.nix.

maintain_env <- function() {
  library(rix) # Ensure rix is attached

  # 1. Read DESCRIPTION file
  desc <- read.dcf("DESCRIPTION")

  # 2. Extract Imports and Suggests packages
  # Convert to character vector, remove version constraints
  get_packages <- function(field) {
    pkgs_str <- desc[1, field]
    if (is.null(pkgs_str) || is.na(pkgs_str)) return(character(0))
    pkgs <- strsplit(pkgs_str, ",")[[1]]
    pkgs <- trimws(pkgs)
    # Remove version constraints (e.g., "pkg (>= 1.0.0)")
    pkgs <- gsub("\\s*\\([^)]*\\)", "", pkgs)
    pkgs <- pkgs[pkgs != "R"] # Exclude R itself
    return(pkgs)
  }

  imports_pkgs <- get_packages("Imports")
  suggests_pkgs <- get_packages("Suggests")
  
  # Add common development packages if not already included
  dev_pkgs <- c("devtools", "usethis", "gert", "gh", "rix", "testthat")
  all_pkgs <- unique(c(imports_pkgs, suggests_pkgs, dev_pkgs))
  
  # Remove any empty strings that might result from parsing
  all_pkgs <- all_pkgs[all_pkgs != ""]
  
  # Sort for consistency
  all_pkgs <- sort(all_pkgs)

  # 3. Write packages.R
  # This file will be sourced by default.R
  packages_r_content <- paste0(
    "# This file is automatically generated by R/setup/maintain_env.R\n",
    "# Do not edit this file directly.\n\n",
    "r_pkgs <- c(\\n  \"", paste(all_pkgs, collapse = "\",\n  \""), "\"\n)"
  )
  writeLines(packages_r_content, "packages.R")
  message("Generated packages.R with: ", paste(all_pkgs, collapse = ", "))

  # 4. Generate default.nix using rix
  # Check if rix is available in the current R environment
  if (!requireNamespace("rix", quietly = TRUE)) {
    message("rix package not found. Please ensure it's installed or available in the environment.")
    # Attempt to load from the project's nix-shell context if possible
    # This part is tricky if the agent cannot restart its own R session
    # For now, we assume rix should be present in the main environment.
    return(invisible(FALSE))
  }
  
  # Read current default.nix to extract existing rev and sha for git_pkgs
  current_default_nix <- readLines("default.nix")
  
  # Extract current git_pkgs information from default.nix for 'ahead', 'esgtoolkit', 'misc'
  # This is a bit brittle, might need a more robust parsing
  extract_git_pkg_info <- function(pkg_name, nix_content) {
    pkg_start_idx <- grep(paste0(pkg_name, " = \\(pkgs.rPackages.buildRPackage \\{"), nix_content, fixed = TRUE)
    if (length(pkg_start_idx) == 0) return(NULL)
    
    # Find the end of the package definition (usually '});' closing the buildRPackage call)
    pkg_end_idx <- grep("^\\s*}\\);", nix_content[pkg_start_idx:length(nix_content)])[1] + pkg_start_idx - 1
    if (is.na(pkg_end_idx)) return(NULL)

    pkg_block <- nix_content[pkg_start_idx:pkg_end_idx]

    rev_line <- grep('rev = "', pkg_block, value = TRUE)
    sha_line <- grep('sha256 = "', pkg_block, value = TRUE)

    rev <- if (length(rev_line) > 0) gsub('.*rev = "([^"]+)".*', "\\1", rev_line) else NULL
    sha <- if (length(sha_line) > 0) gsub('.*sha256 = "([^"]+)".*', "\\1", sha_line) else NULL
    
    if (!is.null(rev) && !is.null(sha)) {
      list(rev = rev, sha = sha)
    } else {
      NULL
    }
  }

  ahead_info <- extract_git_pkg_info("ahead", current_default_nix)
  esgtoolkit_info <- extract_git_pkg_info("esgtoolkit", current_default_nix)
  misc_info <- extract_git_pkg_info("misc", current_default_nix)

  git_pkgs_list <- list()
  if (!is.null(ahead_info)) {
    git_pkgs_list$ahead <- list(
      url = "https://github.com/Techtonique/ahead",
      rev = ahead_info$rev,
      sha256 = ahead_info$sha
    )
  }
  if (!is.null(esgtoolkit_info)) {
    git_pkgs_list$esgtoolkit <- list(
      url = "https://github.com/Techtonique/esgtoolkit",
      rev = esgtoolkit_info$rev,
      sha256 = esgtoolkit_info$sha
    )
  }
    if (!is.null(misc_info)) {
    git_pkgs_list$misc <- list(
      url = "https://github.com/thierrymoudiki/misc",
      rev = misc_info$rev,
      sha256 = misc_info$sha
    )
  }


  # Keep the postPatch logic from the original default.nix
  post_patch_code <- 'postPatch = "rm -f src/*.o src/*.so src/*.dll";'
  
  # Extract r_ver and date from original default.nix
  r_ver_match <- regexec('r_ver = "([^"]+)"', paste(current_default_nix, collapse = "\n"))
  r_ver <- if (r_ver_match[[1]][1] != -1) regmatches(paste(current_default_nix, collapse = "\n"), r_ver_match)[[1]][2] else "4.5.2" # default

  rix(
    r_pkgs = all_pkgs,
    system_pkgs = c(
      "awscli2", "bc", "btop", "cacert", "clang", "cmdstan", "curlMinimal", "direnv", "duckdb", 
      "gcc", "gettext", "gh", "git", "glibcLocales", "gnupg", "htop", "jq", "less", 
      "libgcc", "libiconv", "locale", "nano", "nix", "nodejs", "ollama", "pandoc", 
      "positron-bin", "quarto", "R", "texliveBasic", "toybox", "tree", "typst", "unzip", "which"
    ), # Hardcoded from existing default.nix
    git_pkgs = git_pkgs_list,
    ide = "positron",
    project_path = ".",
    overwrite = TRUE,
    shell_hook = '
mkdir -p $HOME/.config/positron
NIX_SHELL_PATH=$(readlink /Users/johngavin/docs_gh/rix.setup/nix-shell-root)
if [ -z "$NIX_SHELL_PATH" ]; then NIX_SHELL_PATH="$out"; fi

cat > $HOME/.config/positron/nix-terminal-wrapper.sh <<EOF
#!/bin/bash
printf "%s\n" "Activating Nix shell environment..."
true && source $NIX_SHELL_PATH/etc/profile.d/nix-shell.sh

if declare -f __start_nix_shell_environment > /dev/null; then
    __start_nix_shell_environment
fi

printf "%s\n" "Nix environment fully sourced."

echo "set -o emacs" > ~/.nix-shell-bashrc
echo "bind \"\\e[A\": history-search-backward\"" >> ~/.nix-shell-bashrc
echo "bind \"\\e[B\": history-search-forward\"" >> ~/.nix-shell-bashrc
if [ -f ~/.bashrc ]; then source ~/.bashrc; fi

exec /usr/bin/env bash --rcfile ~/.nix-shell-bashrc -i
EOF

chmod +x $HOME/.config/positron/nix-terminal-wrapper.sh
export RSTUDIO_TERM_EXEC=$HOME/.config/positron/nix-terminal-wrapper.sh
export R_MAKEVARS_USER=/dev/null
unset CI
printf "Setup complete\n"
',
    r_ver = r_ver # Use extracted R version
  )
  message("Generated default.nix")
  
  invisible(TRUE)
}
